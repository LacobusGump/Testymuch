<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>GUMP: Cinematic Void Engine - Orchestral Journey</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    body {
      background: #000;
      color: #fff;
      overflow: hidden;
      touch-action: none;
      height: 100vh;
      font-family: 'Courier New', monospace;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 2s ease;
    }
    
    .start-screen {
      text-align: center;
      z-index: 100;
    }
    
    .start-btn {
      width: 200px;
      height: 200px;
      border-radius: 50%;
      background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, transparent 70%);
      border: 2px solid rgba(255,255,255,0.3);
      color: #fff;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      font-weight: bold;
      letter-spacing: 2px;
      backdrop-filter: blur(10px);
      transition: all 0.3s ease;
      animation: pulse 6s ease-in-out infinite;
    }
    
    .start-btn:hover {
      border-color: rgba(255,255,255,0.6);
      background: radial-gradient(circle, rgba(255,255,255,0.2) 0%, transparent 70%);
      transform: scale(1.05);
    }
    
    @keyframes pulse {
      0%, 100% { transform: scale(1); box-shadow: 0 0 30px rgba(255,255,255,0.2); }
      50% { transform: scale(1.08); box-shadow: 0 0 60px rgba(255,255,255,0.4); }
    }
    
    .evolution-space {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      opacity: 0;
      transition: opacity 2s ease;
    }
    
    .evolution-space.active { opacity: 1; }
    
    .orb {
      position: absolute;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: radial-gradient(circle, #fff 0%, rgba(255,255,255,0.3) 50%, transparent 80%);
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
      box-shadow: 0 0 40px rgba(255,255,255,0.5);
      backdrop-filter: blur(5px);
    }
    
    .orb.pulse {
      animation: beat 0.15s ease-out;
    }
    
    @keyframes beat {
      0% { transform: translate(-50%, -50%) scale(1); }
      50% { transform: translate(-50%, -50%) scale(2.2); }
      100% { transform: translate(-50%, -50%) scale(1); }
    }
    
    .orb.awakening {
      background: radial-gradient(circle, #333 0%, rgba(51,51,51,0.3) 50%, transparent 80%);
      box-shadow: 0 0 30px rgba(255,255,255,0.2);
    }
    
    .orb.discovery {
      background: radial-gradient(circle, #4a5568 0%, rgba(74,85,104,0.4) 50%, transparent 80%);
      box-shadow: 0 0 50px rgba(74,85,104,0.5);
    }
    
    .orb.journey {
      background: radial-gradient(circle, #ff6b35 0%, rgba(255,107,53,0.4) 50%, transparent 80%);
      box-shadow: 0 0 60px rgba(255,107,53,0.7);
    }
    
    .orb.conflict {
      background: radial-gradient(circle, #e53e3e 0%, rgba(229,62,62,0.5) 50%, transparent 80%);
      box-shadow: 0 0 80px rgba(229,62,62,0.8);
    }
    
    .orb.triumph {
      background: radial-gradient(circle, #d69e2e 0%, rgba(214,158,46,0.6) 50%, transparent 80%);
      box-shadow: 0 0 100px rgba(214,158,46,0.9);
    }
    
    .orb.transcendent {
      background: radial-gradient(circle, #9b59b6 0%, #e74c3c 40%, #f39c12 70%, transparent 90%);
      box-shadow: 0 0 120px rgba(155,89,182,0.8);
      animation: transcend 3s ease-in-out infinite;
    }
    
    @keyframes transcend {
      0%, 100% { transform: translate(-50%, -50%) scale(1) rotate(0deg); }
      50% { transform: translate(-50%, -50%) scale(1.4) rotate(180deg); }
    }
    
    .ui-corner {
      position: fixed;
      font-size: 11px;
      color: rgba(255,255,255,0.8);
      font-weight: normal;
      letter-spacing: 1px;
      background: rgba(0,0,0,0.3);
      padding: 10px;
      border-radius: 5px;
      backdrop-filter: blur(10px);
    }
    
    .ui-corner.top-left {
      top: 20px;
      left: 20px;
    }
    
    .ui-corner.bottom-left {
      bottom: 20px;
      left: 20px;
    }
    
    .ui-corner.top-right {
      top: 20px;
      right: 20px;
    }
    
    .stage-name {
      font-size: 14px;
      color: rgba(255,255,255,0.9);
      margin-bottom: 8px;
      font-weight: bold;
    }
    
    .metric {
      margin: 3px 0;
      font-size: 10px;
    }
    
    .bar {
      width: 80px;
      height: 3px;
      background: rgba(255,255,255,0.2);
      margin: 3px 0;
      border-radius: 2px;
      overflow: hidden;
    }
    
    .bar-fill {
      height: 100%;
      background: linear-gradient(90deg, #4a90e2, #9b59b6);
      width: 0%;
      transition: width 0.3s ease;
      border-radius: 2px;
    }
    
    .hidden { display: none !important; }
    
    .particles {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      pointer-events: none;
      z-index: 1;
    }
    
    .particle {
      position: absolute;
      width: 3px;
      height: 3px;
      border-radius: 50%;
      background: rgba(255,255,255,0.3);
      animation: float 12s linear infinite;
    }
    
    @keyframes float {
      0% { 
        transform: translateY(100vh) scale(0) rotate(0deg); 
        opacity: 0; 
      }
      10% { opacity: 1; }
      90% { opacity: 1; }
      100% { 
        transform: translateY(-20vh) scale(1.5) rotate(360deg); 
        opacity: 0; 
      }
    }
    
    .instruction {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 14px;
      color: rgba(255,255,255,0.7);
      text-align: center;
      letter-spacing: 2px;
      opacity: 0;
      transition: opacity 2s ease;
      margin-top: 80px;
      font-weight: bold;
    }
    
    .instruction.show { opacity: 1; }

    .cinematic-overlay {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      pointer-events: none;
      background: radial-gradient(circle at center, transparent 30%, rgba(0,0,0,0.6) 100%);
      opacity: 0;
      transition: opacity 3s ease;
      z-index: 2;
    }
    
    .cinematic-overlay.active { opacity: 1; }
    
    .theme-text {
      position: fixed;
      bottom: 30px;
      right: 30px;
      font-size: 12px;
      color: rgba(255,255,255,0.6);
      text-transform: uppercase;
      letter-spacing: 3px;
      opacity: 0;
      transition: opacity 2s ease;
      font-weight: bold;
    }
    
    .theme-text.visible { opacity: 1; }
    
    .act-indicator {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 18px;
      color: rgba(255,255,255,0.9);
      text-transform: uppercase;
      letter-spacing: 4px;
      opacity: 0;
      transition: opacity 2s ease;
      font-weight: bold;
      text-align: center;
    }
    
    .act-indicator.visible { opacity: 1; }
    
    .act-subtitle {
      font-size: 12px;
      color: rgba(255,255,255,0.6);
      margin-top: 5px;
      letter-spacing: 2px;
    }

    .spectrum-viz {
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 100px;
      pointer-events: none;
      z-index: 3;
    }
    
    .spectrum-bar {
      position: absolute;
      bottom: 0;
      width: 8px;
      background: linear-gradient(0deg, rgba(255,255,255,0.8), rgba(255,255,255,0.2));
      border-radius: 4px 4px 0 0;
      transition: height 0.1s ease;
    }
    
    .timeline-bar {
      position: fixed;
      bottom: 110px;
      left: 20px;
      right: 20px;
      height: 4px;
      background: rgba(255,255,255,0.1);
      border-radius: 2px;
    }
    
    .timeline-progress {
      height: 100%;
      background: linear-gradient(90deg, #4a90e2, #9b59b6);
      border-radius: 2px;
      width: 0%;
      transition: width 1s ease;
    }
    
    .time-display {
      position: fixed;
      bottom: 120px;
      left: 20px;
      font-size: 10px;
      color: rgba(255,255,255,0.6);
      letter-spacing: 1px;
    }
  </style>
</head>
<body>
  <div class="start-screen" id="startScreen">
    <div class="start-btn" id="startBtn">
AWAKEN
    </div>
  </div>
  
  <div class="evolution-space" id="evolutionSpace">
    <div class="orb awakening" id="orb"></div>
    
    <div class="instruction" id="instruction">MOVE TO COMPOSE THE SYMPHONY</div>
    
    <div class="act-indicator" id="actIndicator">
      <div id="actName">PRELUDE</div>
      <div class="act-subtitle" id="actSubtitle">The Void Awakens</div>
    </div>
    
    <div class="ui-corner top-left">
      <div class="stage-name" id="stageName">SILENCE</div>
      <div class="metric">MOVEMENT: <span id="movementName">INTRODUCTION</span></div>
      <div class="metric">THEME: <span id="currentTheme">MAIN</span></div>
    </div>
    
    <div class="ui-corner bottom-left">
      <div class="metric">TENSION</div>
      <div class="bar">
        <div class="bar-fill" id="tensionBar"></div>
      </div>
      <div class="metric">DYNAMICS</div>
      <div class="bar">
        <div class="bar-fill" id="dynamicsBar"></div>
      </div>
    </div>
    
    <div class="ui-corner top-right">
      <div class="metric">BPM: <span id="bpmDisplay">40</span></div>
      <div class="metric">KEY: <span id="keyDisplay">D MIN</span></div>
      <div class="metric">VOICES: <span id="voiceCount">0</span></div>
    </div>
    
    <div class="timeline-bar">
      <div class="timeline-progress" id="timelineProgress"></div>
    </div>
    <div class="time-display">
      <span id="currentTime">0:00</span> / <span id="totalTime">8:00</span>
    </div>
    
    <div class="spectrum-viz" id="spectrumViz"></div>
  </div>

  <div class="cinematic-overlay" id="cinematicOverlay"></div>
  <div class="theme-text" id="themeText"></div>

  <script>
    class CinematicOrchestra {
      constructor() {
        this.ctx = null;
        this.active = false;
        this.startTime = 0;
        this.currentTime = 0;
        
        // Musical Timeline (8 minutes total)
        this.timeline = {
          totalDuration: 480, // 8 minutes in seconds
          acts: [
            {
              name: 'PRELUDE',
              subtitle: 'The Void Awakens',
              start: 0,
              duration: 60,
              movements: [
                { name: 'SILENCE', start: 0, duration: 15, theme: 'void' },
                { name: 'AWAKENING', start: 15, duration: 45, theme: 'main' }
              ]
            },
            {
              name: 'ACT I',
              subtitle: 'Discovery of Motion',
              start: 60,
              duration: 120,
              movements: [
                { name: 'FIRST STEPS', start: 60, duration: 30, theme: 'main' },
                { name: 'EXPLORATION', start: 90, duration: 30, theme: 'secondary' },
                { name: 'UNDERSTANDING', start: 120, duration: 30, theme: 'main-varied' },
                { name: 'MOMENTUM', start: 150, duration: 30, theme: 'bridge' }
              ]
            },
            {
              name: 'ACT II', 
              subtitle: 'The Journey Intensifies',
              start: 180,
              duration: 120,
              movements: [
                { name: 'RISING ACTION', start: 180, duration: 40, theme: 'secondary-developed' },
                { name: 'CONFLICT', start: 220, duration: 40, theme: 'tension' },
                { name: 'STRUGGLE', start: 260, duration: 40, theme: 'main-minor' }
              ]
            },
            {
              name: 'ACT III',
              subtitle: 'Climax and Resolution', 
              start: 300,
              duration: 120,
              movements: [
                { name: 'BREAKTHROUGH', start: 300, duration: 30, theme: 'triumph' },
                { name: 'APOTHEOSIS', start: 330, duration: 50, theme: 'all-themes' },
                { name: 'TRANSCENDENCE', start: 380, duration: 40, theme: 'main-transformed' }
              ]
            },
            {
              name: 'CODA',
              subtitle: 'Return to the Void',
              start: 420,
              duration: 60,
              movements: [
                { name: 'REFLECTION', start: 420, duration: 40, theme: 'main-ethereal' },
                { name: 'ETERNAL', start: 460, duration: 20, theme: 'void' }
              ]
            }
          ]
        };
        
        // Current position in timeline
        this.currentAct = null;
        this.currentMovement = null;
        
        // Themes and Leitmotifs  
        this.themes = {
          main: {
            name: 'Hero\'s Theme',
            intervals: [0, 2, -1, 5, 4, 2, 7, 5], // More complex melodic line
            rhythm: [1, 0.5, 0.5, 2, 1, 1, 1, 2],
            character: 'noble'
          },
          secondary: {
            name: 'Mystery Theme',
            intervals: [0, 1, 3, 1, 6, 5, 3, 1],
            rhythm: [1.5, 0.5, 1, 1, 0.5, 0.5, 1, 2],
            character: 'mysterious'
          },
          void: {
            name: 'Void Theme',
            intervals: [0],
            rhythm: [8],
            character: 'ethereal'
          },
          tension: {
            name: 'Conflict Theme',
            intervals: [0, 1, 0, 6, 0, 1, 0, 11],
            rhythm: [0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5],
            character: 'aggressive'
          },
          triumph: {
            name: 'Victory Theme',
            intervals: [0, 4, 7, 12, 11, 7, 4, 0],
            rhythm: [2, 1, 1, 3, 0.5, 0.5, 1, 3],
            character: 'majestic'
          }
        };
        
        // Motion & Orchestra
        this.motion = 0;
        this.intensity = 0;
        this.tension = 0;
        this.dynamics = 0.1;
        this.pos = { x: 50, y: 50 };
        this.velocity = { x: 0, y: 0 };
        this.lastAccel = { x: 0, y: 0, z: 0 };
        this.motionHistory = [];
        
        // Musical State
        this.bpm = 40; // Start very slow
        this.step = 0;
        this.currentTheme = 'void';
        this.themeIndex = 0;
        this.key = 'D';
        this.mode = 'minor';
        this.transposition = 0;
        
        // Orchestra Sections
        this.orchestra = {
          strings: {
            violins1: { voices: 16, active: false, volume: 0.3 },
            violins2: { voices: 14, active: false, volume: 0.25 },
            violas: { voices: 12, active: false, volume: 0.3 },
            cellos: { voices: 10, active: false, volume: 0.35 },
            basses: { voices: 8, active: false, volume: 0.4 }
          },
          brass: {
            horns: { voices: 4, active: false, volume: 0.4 },
            trumpets: { voices: 3, active: false, volume: 0.35 },
            trombones: { voices: 3, active: false, volume: 0.4 },
            tuba: { voices: 1, active: false, volume: 0.5 }
          },
          woodwinds: {
            flutes: { voices: 3, active: false, volume: 0.2 },
            oboes: { voices: 2, active: false, volume: 0.25 },
            clarinets: { voices: 3, active: false, volume: 0.22 },
            bassoons: { voices: 2, active: false, volume: 0.3 }
          },
          percussion: {
            timpani: { voices: 4, active: false, volume: 0.6 },
            cymbals: { voices: 1, active: false, volume: 0.4 },
            bassDrum: { voices: 1, active: false, volume: 0.7 },
            snare: { voices: 1, active: false, volume: 0.3 },
            bells: { voices: 1, active: false, volume: 0.15 }
          },
          choir: {
            soprano: { voices: 20, active: false, volume: 0.2 },
            alto: { voices: 20, active: false, volume: 0.2 },
            tenor: { voices: 20, active: false, volume: 0.2 },
            bass: { voices: 20, active: false, volume: 0.25 }
          },
          electronics: {
            pads: { voices: 8, active: false, volume: 0.15 },
            atmospheres: { voices: 4, active: false, volume: 0.1 },
            pulses: { voices: 6, active: false, volume: 0.2 }
          }
        };
        
        // Audio nodes
        this.masterGain = null;
        this.analyser = null;
        this.convolver = null;
        this.compressor = null;
        this.sectionGains = {};
        
        // Voice allocation
        this.activeVoices = [];
        this.maxVoices = 128;
        
        // UI Elements
        this.elements = {};
        
        this.init();
      }

      init() {
        ['startScreen', 'startBtn', 'evolutionSpace', 'orb', 'instruction',
         'stageName', 'movementName', 'currentTheme', 'tensionBar', 'dynamicsBar',
         'bpmDisplay', 'keyDisplay', 'voiceCount', 'cinematicOverlay', 'themeText',
         'spectrumViz', 'actIndicator', 'actName', 'actSubtitle', 'timelineProgress',
         'currentTime', 'totalTime']
        .forEach(id => this.elements[id] = document.getElementById(id));
        
        this.elements.startBtn.onclick = () => this.start();
        this.setupMotionDetection();
        this.setupSpectrumVisualizer();
        
        // Set total time display
        this.elements.totalTime.textContent = this.formatTime(this.timeline.totalDuration);
      }

      setupSpectrumVisualizer() {
        this.spectrumBars = [];
        for (let i = 0; i < 64; i++) {
          const bar = document.createElement('div');
          bar.className = 'spectrum-bar';
          bar.style.left = `${i * 1.5625}%`;
          bar.style.height = '0px';
          this.elements.spectrumViz.appendChild(bar);
          this.spectrumBars.push(bar);
        }
      }

      async start() {
        try {
          // Request permissions
          if (typeof DeviceMotionEvent?.requestPermission === 'function') {
            await DeviceMotionEvent.requestPermission();
          }

          this.ctx = new (window.AudioContext || window.webkitAudioContext)();
          await this.ctx.resume();
          this.setupAudioChain();

          this.elements.startScreen.classList.add('hidden');
          this.elements.evolutionSpace.classList.add('active');
          
          setTimeout(() => {
            this.elements.instruction.classList.add('show');
            setTimeout(() => this.elements.instruction.classList.remove('show'), 4000);
          }, 1000);

          this.active = true;
          this.startTime = this.ctx.currentTime;
          this.startOrchestra();
          this.animate();
          
        } catch (e) {
          console.error('Failed to start:', e);
          alert('Failed to initialize. Please try again.');
        }
      }

      setupAudioChain() {
        // Master chain
        this.masterGain = this.ctx.createGain();
        this.masterGain.gain.value = 0.6;
        
        this.compressor = this.ctx.createDynamicsCompressor();
        this.compressor.threshold.value = -12;
        this.compressor.knee.value = 8;
        this.compressor.ratio.value = 4;
        this.compressor.attack.value = 0.003;
        this.compressor.release.value = 0.25;
        
        this.convolver = this.ctx.createConvolver();
        this.convolver.buffer = this.createReverbBuffer(3);
        
        const convolverGain = this.ctx.createGain();
        convolverGain.gain.value = 0.3;
        
        this.analyser = this.ctx.createAnalyser();
        this.analyser.fftSize = 128;
        this.dataArray = new Uint8Array(this.analyser.frequencyBinCount);
        
        // Create section gains
        Object.keys(this.orchestra).forEach(section => {
          this.sectionGains[section] = this.ctx.createGain();
          this.sectionGains[section].gain.value = 0.8;
          this.sectionGains[section].connect(this.compressor);
          this.sectionGains[section].connect(this.convolver);
        });
        
        this.convolver.connect(convolverGain);
        convolverGain.connect(this.compressor);
        this.compressor.connect(this.analyser);
        this.analyser.connect(this.masterGain);
        this.masterGain.connect(this.ctx.destination);
      }

      createReverbBuffer(seconds) {
        const length = this.ctx.sampleRate * seconds;
        const buffer = this.ctx.createBuffer(2, length, this.ctx.sampleRate);
        
        for (let channel = 0; channel < 2; channel++) {
          const channelData = buffer.getChannelData(channel);
          for (let i = 0; i < length; i++) {
            channelData[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, 2);
          }
        }
        
        return buffer;
      }

      setupMotionDetection() {
        // Device motion
        window.addEventListener('devicemotion', e => {
          if (!this.active) return;
          
          const acc = e.accelerationIncludingGravity;
          if (!acc || acc.x === null) return;

          const dx = Math.abs(acc.x - this.lastAccel.x);
          const dy = Math.abs(acc.y - this.lastAccel.y);
          const dz = Math.abs(acc.z - this.lastAccel.z);
          
          const newMotion = Math.sqrt(dx * dx + dy * dy + dz * dz) * 0.5;
          this.updateMotion(newMotion);
          
          this.velocity.x += acc.x * 0.01;
          this.velocity.y += acc.y * 0.01;
          this.updatePosition();
          
          this.lastAccel = { x: acc.x, y: acc.y, z: acc.z };
        });

        // Mouse motion
        let lastMouse = { x: 0, y: 0, time: 0 };
        window.addEventListener('mousemove', e => {
          if (!this.active) return;
          
          const now = Date.now();
          const dt = Math.max(1, now - lastMouse.time);
          
          const newX = (e.clientX / window.innerWidth) * 100;
          const newY = (e.clientY / window.innerHeight) * 100;
          
          const velocityX = (newX - lastMouse.x) / dt * 100;
          const velocityY = (newY - lastMouse.y) / dt * 100;
          
          const mouseMotion = Math.sqrt(velocityX * velocityX + velocityY * velocityY) * 0.1;
          this.updateMotion(mouseMotion);
          
          this.pos.x = newX;
          this.pos.y = newY;
          
          lastMouse = { x: newX, y: newY, time: now };
        });
      }

      updateMotion(newMotion) {
        this.motion = this.motion * 0.85 + newMotion * 0.15;
        this.motionHistory.push(this.motion);
        if (this.motionHistory.length > 120) this.motionHistory.shift();
        
        // Calculate intensity and tension
        const avgMotion = this.motionHistory.reduce((a, b) => a + b, 0) / this.motionHistory.length;
        const variance = this.motionHistory.reduce((sum, m) => sum + Math.abs(m - avgMotion), 0) / this.motionHistory.length;
        
        this.intensity = Math.min(avgMotion / 5, 1);
        this.tension = Math.min(variance / 3, 1);
        
        // Update dynamics based on timeline position
        this.updateDynamics();
      }

      updatePosition() {
        this.pos.x += this.velocity.x;
        this.pos.y += this.velocity.y;
        
        if (this.pos.x < 5 || this.pos.x > 95) this.velocity.x *= -0.8;
        if (this.pos.y < 5 || this.pos.y > 95) this.velocity.y *= -0.8;
        
        this.pos.x = Math.max(5, Math.min(95, this.pos.x));
        this.pos.y = Math.max(5, Math.min(95, this.pos.y));
        
        this.velocity.x *= 0.92;
        this.velocity.y *= 0.92;
      }

      updateDynamics() {
        // Base dynamics on timeline position and motion
        const timeProgress = this.currentTime / this.timeline.totalDuration;
        let targetDynamics = 0.1;
        
        // Dynamics curve based on act
        if (this.currentAct) {
          switch(this.currentAct.name) {
            case 'PRELUDE': targetDynamics = 0.1 + this.intensity * 0.2; break;
            case 'ACT I': targetDynamics = 0.2 + this.intensity * 0.3; break;
            case 'ACT II': targetDynamics = 0.4 + this.intensity * 0.4; break;
            case 'ACT III': targetDynamics = 0.6 + this.intensity * 0.4; break;
            case 'CODA': targetDynamics = 0.3 - timeProgress * 0.2; break;
          }
        }
        
        // Add tension modifier
        targetDynamics += this.tension * 0.2;
        
        // Smooth transition
        this.dynamics = this.dynamics * 0.9 + targetDynamics * 0.1;
        this.dynamics = Math.max(0.05, Math.min(1, this.dynamics));
        
        // Update master volume
        this.masterGain.gain.setTargetAtTime(this.dynamics * 0.6, this.ctx.currentTime, 0.5);
      }

      startOrchestra() {
        const tick = () => {
          if (!this.active) return;
          
          this.currentTime = this.ctx.currentTime - this.startTime;
          this.updateTimeline();
          this.orchestrate();
          
          // Adaptive tempo based on movement
          if (this.currentMovement) {
            let targetBPM = 40;
            switch(this.currentMovement.name) {
              case 'SILENCE': targetBPM = 40; break;
              case 'AWAKENING': targetBPM = 50 + this.intensity * 10; break;
              case 'FIRST STEPS': targetBPM = 60 + this.intensity * 15; break;
              case 'EXPLORATION': targetBPM = 70 + this.intensity * 20; break;
              case 'MOMENTUM': targetBPM = 80 + this.intensity * 25; break;
              case 'RISING ACTION': targetBPM = 90 + this.intensity * 30; break;
              case 'CONFLICT': targetBPM = 100 + this.intensity * 40; break;
              case 'APOTHEOSIS': targetBPM = 120 + this.intensity * 40; break;
              case 'REFLECTION': targetBPM = 60 - this.currentTime % 60; break;
              case 'ETERNAL': targetBPM = 40; break;
              default: targetBPM = 70 + this.intensity * 30;
            }
            
            this.bpm = this.bpm * 0.95 + targetBPM * 0.05;
          }
          
          const interval = (60 / this.bpm) * 1000 / 4; // 16th notes
          setTimeout(tick, interval);
          
          this.step++;
        };
        tick();
      }

      updateTimeline() {
        // Find current act and movement
        let foundAct = null;
        let foundMovement = null;
        
        for (const act of this.timeline.acts) {
          if (this.currentTime >= act.start && this.currentTime < act.start + act.duration) {
            foundAct = act;
            
            for (const movement of act.movements) {
              if (this.currentTime >= movement.start && this.currentTime < movement.start + movement.duration) {
                foundMovement = movement;
                break;
              }
            }
            break;
          }
        }
        
        // Update if changed
        if (foundAct !== this.currentAct) {
          this.currentAct = foundAct;
          if (foundAct) {
            this.elements.actName.textContent = foundAct.name;
            this.elements.actSubtitle.textContent = foundAct.subtitle;
            this.elements.actIndicator.classList.add('visible');
            setTimeout(() => this.elements.actIndicator.classList.remove('visible'), 5000);
            this.updateOrbStyle();
          }
        }
        
        if (foundMovement !== this.currentMovement) {
          this.currentMovement = foundMovement;
          if (foundMovement) {
            this.currentTheme = foundMovement.theme;
            this.themeIndex = 0;
            this.elements.movementName.textContent = foundMovement.name;
            this.elements.currentTheme.textContent = this.getThemeName(foundMovement.theme);
            this.updateOrchestration();
          }
        }
        
        // Update progress
        const progress = (this.currentTime / this.timeline.totalDuration) * 100;
        this.elements.timelineProgress.style.width = progress + '%';
        this.elements.currentTime.textContent = this.formatTime(this.currentTime);
        
        // End piece
        if (this.currentTime >= this.timeline.totalDuration) {
          this.fadeOut();
        }
      }

      updateOrbStyle() {
        const styles = {
          'PRELUDE': 'awakening',
          'ACT I': 'discovery',
          'ACT II': 'journey',
          'ACT III': 'triumph',
          'CODA': 'transcendent'
        };
        
        const style = styles[this.currentAct.name] || 'awakening';
        this.elements.orb.className = `orb ${style}`;
      }

      getThemeName(themeKey) {
        const names = {
          'void': 'VOID',
          'main': 'HERO',
          'main-varied': 'HERO VAR.',
          'main-minor': 'HERO DARK',
          'main-transformed': 'HERO TRIUMPH',
          'main-ethereal': 'HERO ETHEREAL',
          'secondary': 'MYSTERY',
          'secondary-developed': 'MYSTERY DEV.',
          'bridge': 'JOURNEY',
          'tension': 'CONFLICT',
          'triumph': 'VICTORY',
          'all-themes': 'SYNTHESIS'
        };
        return names[themeKey] || themeKey.toUpperCase();
      }

      updateOrchestration() {
        // Reset all sections
        Object.values(this.orchestra).forEach(section => {
          Object.values(section).forEach(instrument => {
            instrument.active = false;
          });
        });
        
        // Activate based on movement
        if (!this.currentMovement) return;
        
        const orchestrations = {
          'SILENCE': () => {
            // Nothing
          },
          'AWAKENING': () => {
            this.orchestra.strings.basses.active = true;
            this.orchestra.electronics.atmospheres.active = true;
          },
          'FIRST STEPS': () => {
            this.orchestra.strings.cellos.active = true;
            this.orchestra.strings.basses.active = true;
            this.orchestra.woodwinds.bassoons.active = true;
            if (this.intensity > 0.3) this.orchestra.strings.violas.active = true;
          },
          'EXPLORATION': () => {
            this.orchestra.strings.violins2.active = true;
            this.orchestra.strings.violas.active = true;
            this.orchestra.strings.cellos.active = true;
            this.orchestra.woodwinds.clarinets.active = true;
            this.orchestra.woodwinds.flutes.active = this.intensity > 0.4;
            this.orchestra.electronics.pulses.active = this.tension > 0.3;
          },
          'UNDERSTANDING': () => {
            this.orchestra.strings.violins1.active = true;
            this.orchestra.strings.violins2.active = true;
            this.orchestra.strings.violas.active = true;
            this.orchestra.woodwinds.oboes.active = true;
            this.orchestra.brass.horns.active = this.intensity > 0.5;
          },
          'MOMENTUM': () => {
            this.orchestra.strings.violins1.active = true;
            this.orchestra.strings.violins2.active = true;
            this.orchestra.strings.cellos.active = true;
            this.orchestra.percussion.timpani.active = true;
            this.orchestra.brass.horns.active = true;
            this.orchestra.electronics.pulses.active = true;
          },
          'RISING ACTION': () => {
            // Full strings
            Object.values(this.orchestra.strings).forEach(i => i.active = true);
            this.orchestra.brass.horns.active = true;
            this.orchestra.brass.trombones.active = this.intensity > 0.6;
            this.orchestra.percussion.timpani.active = true;
            this.orchestra.percussion.bassDrum.active = this.tension > 0.7;
          },
          'CONFLICT': () => {
            // Almost full orchestra
            Object.values(this.orchestra.strings).forEach(i => i.active = true);
            Object.values(this.orchestra.brass).forEach(i => i.active = this.intensity > 0.4);
            this.orchestra.percussion.timpani.active = true;
            this.orchestra.percussion.snare.active = true;
            this.orchestra.percussion.cymbals.active = this.tension > 0.8;
          },
          'STRUGGLE': () => {
            // Selective, tense orchestration
            this.orchestra.strings.violins1.active = true;
            this.orchestra.strings.cellos.active = true;
            this.orchestra.strings.basses.active = true;
            this.orchestra.brass.trumpets.active = this.intensity > 0.7;
            this.orchestra.brass.trombones.active = true;
            this.orchestra.percussion.timpani.active = true;
            this.orchestra.electronics.atmospheres.active = true;
          },
          'BREAKTHROUGH': () => {
            // Building to full
            Object.values(this.orchestra).forEach(section => {
              Object.values(section).forEach(instrument => {
                instrument.active = Math.random() < this.intensity;
              });
            });
          },
          'APOTHEOSIS': () => {
            // FULL ORCHESTRA
            Object.values(this.orchestra).forEach(section => {
              Object.values(section).forEach(instrument => {
                instrument.active = true;
              });
            });
          },
          'TRANSCENDENCE': () => {
            // Ethereal full orchestra
            Object.values(this.orchestra.strings).forEach(i => i.active = true);
            this.orchestra.brass.horns.active = true;
            this.orchestra.woodwinds.flutes.active = true;
            this.orchestra.choir.soprano.active = true;
            this.orchestra.choir.alto.active = true;
            this.orchestra.percussion.bells.active = true;
            this.orchestra.electronics.pads.active = true;
          },
          'REFLECTION': () => {
            // Sparse, beautiful
            this.orchestra.strings.violins1.active = this.step % 32 < 16;
            this.orchestra.strings.cellos.active = true;
            this.orchestra.woodwinds.flutes.active = true;
            this.orchestra.electronics.atmospheres.active = true;
            this.orchestra.choir.soprano.active = this.intensity < 0.3;
          },
          'ETERNAL': () => {
            // Fading to nothing
            this.orchestra.strings.basses.active = this.currentTime % 4 < 2;
            this.orchestra.electronics.atmospheres.active = true;
          }
        };
        
        const orchestration = orchestrations[this.currentMovement.name];
        if (orchestration) orchestration();
      }

      orchestrate() {
        // Clean up finished voices
        this.activeVoices = this.activeVoices.filter(v => v.endTime > this.ctx.currentTime);
        
        // Check voice limit
        if (this.activeVoices.length >= this.maxVoices) return;
        
        // Get current theme
        const theme = this.themes[this.currentTheme] || this.themes.void;
        
        // Orchestrate active sections
        if (this.step % 4 === 0) { // Quarter notes
          // Strings
          if (this.orchestra.strings.violins1.active && Math.random() < 0.8) {
            this.playViolin1(theme);
          }
          if (this.orchestra.strings.violins2.active && Math.random() < 0.7) {
            this.playViolin2(theme);
          }
          if (this.orchestra.strings.violas.active && this.step % 8 === 0) {
            this.playViola(theme);
          }
          if (this.orchestra.strings.cellos.active && this.step % 8 === 0) {
            this.playCello(theme);
          }
          if (this.orchestra.strings.basses.active && this.step % 16 === 0) {
            this.playBass(theme);
          }
          
          // Brass
          if (this.orchestra.brass.horns.active && this.step % 16 === 0) {
            this.playHorns(theme);
          }
          if (this.orchestra.brass.trumpets.active && this.step % 32 === 0) {
            this.playTrumpets(theme);
          }
          if (this.orchestra.brass.trombones.active && this.step % 16 === 8) {
            this.playTrombones(theme);
          }
          
          // Woodwinds  
          if (this.orchestra.woodwinds.flutes.active && this.step % 8 === 4) {
            this.playFlutes(theme);
          }
          if (this.orchestra.woodwinds.oboes.active && this.step % 16 === 0) {
            this.playOboes(theme);
          }
          
          // Percussion
          if (this.orchestra.percussion.timpani.active && this.step % 16 === 0) {
            this.playTimpani();
          }
          if (this.orchestra.percussion.bassDrum.active && this.step % 32 === 0) {
            this.playBassDrum();
          }
          if (this.orchestra.percussion.cymbals.active && this.step % 64 === 0 && this.tension > 0.7) {
            this.playCymbals();
          }
          
          // Choir
          if (this.orchestra.choir.soprano.active && this.step % 64 === 0) {
            this.playChoir('soprano', theme);
          }
          if (this.orchestra.choir.alto.active && this.step % 64 === 32) {
            this.playChoir('alto', theme);
          }
          
          // Electronics
          if (this.orchestra.electronics.atmospheres.active && Math.random() < 0.05) {
            this.playAtmosphere();
          }
          if (this.orchestra.electronics.pulses.active && this.step % 2 === 0) {
            this.playPulse();
          }
        }
      }

      // Instrument implementations
      playViolin1(theme) {
        const noteData = this.getThemeNote(theme);
        if (!noteData) return;
        
        const freq = this.noteToFreq(noteData.note, 4);
        const duration = noteData.duration * (60 / this.bpm);
        
        // Create rich violin sound with multiple oscillators
        for (let i = 0; i < 3; i++) {
          const osc = this.ctx.createOscillator();
          const gain = this.ctx.createGain();
          const filter = this.ctx.createBiquadFilter();
          
          osc.type = 'sawtooth';
          osc.frequency.value = freq * (1 + i * 0.001);
          osc.detune.value = (i - 1) * 8;
          
          filter.type = 'lowpass';
          filter.frequency.value = 2000 + this.intensity * 1000;
          filter.Q.value = 2;
          
          // ADSR envelope
          gain.gain.setValueAtTime(0, this.ctx.currentTime);
          gain.gain.linearRampToValueAtTime(0.1 * this.dynamics, this.ctx.currentTime + 0.05);
          gain.gain.exponentialRampToValueAtTime(0.05 * this.dynamics, this.ctx.currentTime + duration * 0.8);
          gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);
          
          osc.connect(filter);
          filter.connect(gain);
          gain.connect(this.sectionGains.strings);
          
          osc.start();
          osc.stop(this.ctx.currentTime + duration);
          
          this.activeVoices.push({ osc, gain, endTime: this.ctx.currentTime + duration });
        }
      }

      playViolin2(theme) {
        // Harmony line - third below violin 1
        const noteData = this.getThemeNote(theme);
        if (!noteData) return;
        
        const freq = this.noteToFreq(noteData.note - 4, 4); // Third below
        const duration = noteData.duration * (60 / this.bpm);
        
        for (let i = 0; i < 2; i++) {
          const osc = this.ctx.createOscillator();
          const gain = this.ctx.createGain();
          const filter = this.ctx.createBiquadFilter();
          
          osc.type = 'sawtooth';
          osc.frequency.value = freq * (1 + i * 0.002);
          
          filter.type = 'lowpass';
          filter.frequency.value = 1800 + this.intensity * 800;
          filter.Q.value = 2;
          
          gain.gain.setValueAtTime(0, this.ctx.currentTime);
          gain.gain.linearRampToValueAtTime(0.08 * this.dynamics, this.ctx.currentTime + 0.06);
          gain.gain.exponentialRampToValueAtTime(0.04 * this.dynamics, this.ctx.currentTime + duration * 0.8);
          gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);
          
          osc.connect(filter);
          filter.connect(gain);
          gain.connect(this.sectionGains.strings);
          
          osc.start();
          osc.stop(this.ctx.currentTime + duration);
          
          this.activeVoices.push({ osc, gain, endTime: this.ctx.currentTime + duration });
        }
      }

      playViola(theme) {
        const noteData = this.getThemeNote(theme);
        if (!noteData) return;
        
        const freq = this.noteToFreq(noteData.note, 3);
        const duration = noteData.duration * (60 / this.bpm) * 2;
        
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        
        osc.type = 'sawtooth';
        osc.frequency.value = freq;
        
        filter.type = 'lowpass';
        filter.frequency.value = 1200 + this.intensity * 600;
        filter.Q.value = 3;
        
        gain.gain.setValueAtTime(0, this.ctx.currentTime);
        gain.gain.linearRampToValueAtTime(0.12 * this.dynamics, this.ctx.currentTime + 0.08);
        gain.gain.setValueAtTime(0.12 * this.dynamics, this.ctx.currentTime + duration * 0.7);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);
        
        osc.connect(filter);
        filter.connect(gain);
        gain.connect(this.sectionGains.strings);
        
        osc.start();
        osc.stop(this.ctx.currentTime + duration);
        
        this.activeVoices.push({ osc, gain, endTime: this.ctx.currentTime + duration });
      }

      playCello(theme) {
        const noteData = this.getThemeNote(theme);
        if (!noteData) return;
        
        const freq = this.noteToFreq(noteData.note, 2);
        const duration = noteData.duration * (60 / this.bpm) * 2;
        
        const osc1 = this.ctx.createOscillator();
        const osc2 = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        
        osc1.type = 'sawtooth';
        osc1.frequency.value = freq;
        osc2.type = 'square';
        osc2.frequency.value = freq * 0.5;
        
        filter.type = 'lowpass';
        filter.frequency.value = 800 + this.intensity * 400;
        filter.Q.value = 4;
        
        gain.gain.setValueAtTime(0, this.ctx.currentTime);
        gain.gain.linearRampToValueAtTime(0.15 * this.dynamics, this.ctx.currentTime + 0.1);
        gain.gain.setValueAtTime(0.15 * this.dynamics, this.ctx.currentTime + duration * 0.7);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);
        
        osc1.connect(filter);
        osc2.connect(filter);
        filter.connect(gain);
        gain.connect(this.sectionGains.strings);
        
        osc1.start();
        osc2.start();
        osc1.stop(this.ctx.currentTime + duration);
        osc2.stop(this.ctx.currentTime + duration);
        
        this.activeVoices.push({ osc: osc1, gain, endTime: this.ctx.currentTime + duration });
      }

      playBass(theme) {
        const noteData = this.getThemeNote(theme);
        if (!noteData) return;
        
        const freq = this.noteToFreq(noteData.note, 1);
        const duration = noteData.duration * (60 / this.bpm) * 4;
        
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        
        osc.type = 'sawtooth';
        osc.frequency.value = freq;
        
        filter.type = 'lowpass';
        filter.frequency.value = 400 + this.intensity * 200;
        filter.Q.value = 5;
        
        gain.gain.setValueAtTime(0, this.ctx.currentTime);
        gain.gain.linearRampToValueAtTime(0.2 * this.dynamics, this.ctx.currentTime + 0.15);
        gain.gain.setValueAtTime(0.2 * this.dynamics, this.ctx.currentTime + duration * 0.8);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);
        
        osc.connect(filter);
        filter.connect(gain);
        gain.connect(this.sectionGains.strings);
        
        osc.start();
        osc.stop(this.ctx.currentTime + duration);
        
        this.activeVoices.push({ osc, gain, endTime: this.ctx.currentTime + duration });
      }

      playHorns(theme) {
        // French horns - warm, heroic
        const noteData = this.getThemeNote(theme);
        if (!noteData) return;
        
        const freq = this.noteToFreq(noteData.note, 3);
        const duration = noteData.duration * (60 / this.bpm) * 2;
        
        for (let i = 0; i < 2; i++) {
          const osc = this.ctx.createOscillator();
          const gain = this.ctx.createGain();
          const filter = this.ctx.createBiquadFilter();
          
          osc.type = 'sawtooth';
          osc.frequency.value = freq * (1 + i * 0.005);
          
          filter.type = 'lowpass';
          filter.frequency.value = 600 + this.intensity * 400;
          filter.Q.value = 6;
          
          gain.gain.setValueAtTime(0, this.ctx.currentTime);
          gain.gain.linearRampToValueAtTime(0.15 * this.dynamics, this.ctx.currentTime + 0.2);
          gain.gain.setValueAtTime(0.15 * this.dynamics, this.ctx.currentTime + duration * 0.6);
          gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);
          
          osc.connect(filter);
          filter.connect(gain);
          gain.connect(this.sectionGains.brass);
          
          osc.start();
          osc.stop(this.ctx.currentTime + duration);
          
          this.activeVoices.push({ osc, gain, endTime: this.ctx.currentTime + duration });
        }
      }

      playTrumpets(theme) {
        const noteData = this.getThemeNote(theme);
        if (!noteData) return;
        
        const freq = this.noteToFreq(noteData.note, 4);
        const duration = noteData.duration * (60 / this.bpm);
        
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        
        osc.type = 'sawtooth';
        osc.frequency.value = freq;
        
        filter.type = 'bandpass';
        filter.frequency.value = 1200;
        filter.Q.value = 8;
        
        // Sharp attack for trumpets
        gain.gain.setValueAtTime(0, this.ctx.currentTime);
        gain.gain.linearRampToValueAtTime(0.18 * this.dynamics, this.ctx.currentTime + 0.02);
        gain.gain.exponentialRampToValueAtTime(0.12 * this.dynamics, this.ctx.currentTime + 0.1);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);
        
        osc.connect(filter);
        filter.connect(gain);
        gain.connect(this.sectionGains.brass);
        
        osc.start();
        osc.stop(this.ctx.currentTime + duration);
        
        this.activeVoices.push({ osc, gain, endTime: this.ctx.currentTime + duration });
      }

      playTrombones(theme) {
        const noteData = this.getThemeNote(theme);
        if (!noteData) return;
        
        const freq = this.noteToFreq(noteData.note, 2);
        const duration = noteData.duration * (60 / this.bpm) * 2;
        
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        
        osc.type = 'sawtooth';
        osc.frequency.value = freq;
        
        filter.type = 'lowpass';
        filter.frequency.value = 500 + this.intensity * 300;
        filter.Q.value = 5;
        
        gain.gain.setValueAtTime(0, this.ctx.currentTime);
        gain.gain.linearRampToValueAtTime(0.16 * this.dynamics, this.ctx.currentTime + 0.1);
        gain.gain.setValueAtTime(0.16 * this.dynamics, this.ctx.currentTime + duration * 0.7);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);
        
        osc.connect(filter);
        filter.connect(gain);
        gain.connect(this.sectionGains.brass);
        
        osc.start();
        osc.stop(this.ctx.currentTime + duration);
        
        this.activeVoices.push({ osc, gain, endTime: this.ctx.currentTime + duration });
      }

      playFlutes(theme) {
        const noteData = this.getThemeNote(theme);
        if (!noteData) return;
        
        const freq = this.noteToFreq(noteData.note, 5);
        const duration = noteData.duration * (60 / this.bpm);
        
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        
        // Triangle wave for flute-like sound
        osc.type = 'triangle';
        osc.frequency.value = freq;
        
        filter.type = 'highpass';
        filter.frequency.value = 400;
        filter.Q.value = 1;
        
        gain.gain.setValueAtTime(0, this.ctx.currentTime);
        gain.gain.linearRampToValueAtTime(0.08 * this.dynamics, this.ctx.currentTime + 0.05);
        gain.gain.setValueAtTime(0.08 * this.dynamics, this.ctx.currentTime + duration * 0.8);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);
        
        osc.connect(filter);
        filter.connect(gain);
        gain.connect(this.sectionGains.woodwinds);
        
        osc.start();
        osc.stop(this.ctx.currentTime + duration);
        
        this.activeVoices.push({ osc, gain, endTime: this.ctx.currentTime + duration });
      }

      playOboes(theme) {
        const noteData = this.getThemeNote(theme);
        if (!noteData) return;
        
        const freq = this.noteToFreq(noteData.note, 4);
        const duration = noteData.duration * (60 / this.bpm);
        
        const osc1 = this.ctx.createOscillator();
        const osc2 = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        
        // Double reed simulation
        osc1.type = 'sawtooth';
        osc1.frequency.value = freq;
        osc2.type = 'square';
        osc2.frequency.value = freq * 2;
        
        filter.type = 'bandpass';
        filter.frequency.value = 800;
        filter.Q.value = 10;
        
        gain.gain.setValueAtTime(0, this.ctx.currentTime);
        gain.gain.linearRampToValueAtTime(0.1 * this.dynamics, this.ctx.currentTime + 0.08);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);
        
        osc1.connect(filter);
        osc2.connect(filter);
        filter.connect(gain);
        gain.connect(this.sectionGains.woodwinds);
        
        osc1.start();
        osc2.start();
        osc1.stop(this.ctx.currentTime + duration);
        osc2.stop(this.ctx.currentTime + duration);
        
        this.activeVoices.push({ osc: osc1, gain, endTime: this.ctx.currentTime + duration });
      }

      playTimpani() {
        const freq = 55 + this.tension * 20; // A1 to D2 range
        const duration = 2;
        
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        
        osc.type = 'sine';
        osc.frequency.setValueAtTime(freq * 2, this.ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(freq, this.ctx.currentTime + 0.1);
        
        filter.type = 'lowpass';
        filter.frequency.value = 200;
        filter.Q.value = 5;
        
        gain.gain.setValueAtTime(0.3 * this.dynamics, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);
        
        osc.connect(filter);
        filter.connect(gain);
        gain.connect(this.sectionGains.percussion);
        
        osc.start();
        osc.stop(this.ctx.currentTime + duration);
        
        this.activeVoices.push({ osc, gain, endTime: this.ctx.currentTime + duration });
      }

      playBassDrum() {
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        
        osc.type = 'sine';
        osc.frequency.setValueAtTime(60, this.ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(30, this.ctx.currentTime + 0.5);
        
        gain.gain.setValueAtTime(0.5 * this.dynamics, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 1);
        
        osc.connect(gain);
        gain.connect(this.sectionGains.percussion);
        
        osc.start();
        osc.stop(this.ctx.currentTime + 1);
        
        this.activeVoices.push({ osc, gain, endTime: this.ctx.currentTime + 1 });
      }

      playCymbals() {
        const duration = 4;
        const buffer = this.ctx.createBuffer(1, this.ctx.sampleRate * duration, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        
        // Generate metallic noise
        for (let i = 0; i < data.length; i++) {
          data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / data.length, 0.5);
        }
        
        const source = this.ctx.createBufferSource();
        const gain = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        
        source.buffer = buffer;
        
        filter.type = 'highpass';
        filter.frequency.value = 3000;
        filter.Q.value = 1;
        
        gain.gain.setValueAtTime(0.3 * this.dynamics, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);
        
        source.connect(filter);
        filter.connect(gain);
        gain.connect(this.sectionGains.percussion);
        
        source.start();
      }

      playChoir(voice, theme) {
        const noteData = this.getThemeNote(theme);
        if (!noteData) return;
        
        const octaveMap = { soprano: 5, alto: 4, tenor: 3, bass: 2 };
        const freq = this.noteToFreq(noteData.note, octaveMap[voice]);
        const duration = noteData.duration * (60 / this.bpm) * 8; // Long notes
        
        // Multiple voices for choir effect
        for (let i = 0; i < 4; i++) {
          const osc = this.ctx.createOscillator();
          const gain = this.ctx.createGain();
          const filter = this.ctx.createBiquadFilter();
          
          osc.type = 'sine';
          osc.frequency.value = freq * (1 + (Math.random() - 0.5) * 0.01);
          
          filter.type = 'bandpass';
          filter.frequency.value = voice === 'soprano' ? 800 : 400;
          filter.Q.value = 2;
          
          gain.gain.setValueAtTime(0, this.ctx.currentTime);
          gain.gain.linearRampToValueAtTime(0.05 * this.dynamics, this.ctx.currentTime + 2);
          gain.gain.setValueAtTime(0.05 * this.dynamics, this.ctx.currentTime + duration - 2);
          gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);
          
          osc.connect(filter);
          filter.connect(gain);
          gain.connect(this.sectionGains.choir);
          
          osc.start(this.ctx.currentTime + i * 0.1);
          osc.stop(this.ctx.currentTime + duration);
          
          this.activeVoices.push({ osc, gain, endTime: this.ctx.currentTime + duration });
        }
      }

      playAtmosphere() {
        const duration = 20;
        const freq = 100 + Math.random() * 100;
        
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        
        osc.type = 'sine';
        osc.frequency.value = freq;
        
        filter.type = 'lowpass';
        filter.frequency.value = 200;
        filter.Q.value = 15;
        
        gain.gain.setValueAtTime(0, this.ctx.currentTime);
        gain.gain.linearRampToValueAtTime(0.02 * this.dynamics, this.ctx.currentTime + 5);
        gain.gain.setValueAtTime(0.02 * this.dynamics, this.ctx.currentTime + 15);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);
        
        osc.connect(filter);
        filter.connect(gain);
        gain.connect(this.sectionGains.electronics);
        
        osc.start();
        osc.stop(this.ctx.currentTime + duration);
        
        this.activeVoices.push({ osc, gain, endTime: this.ctx.currentTime + duration });
      }

      playPulse() {
        const freq = this.noteToFreq(0, 2);
        const duration = 0.1;
        
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        
        osc.type = 'square';
        osc.frequency.value = freq;
        
        gain.gain.setValueAtTime(0.05 * this.dynamics * this.intensity, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);
        
        osc.connect(gain);
        gain.connect(this.sectionGains.electronics);
        
        osc.start();
        osc.stop(this.ctx.currentTime + duration);
        
        this.activeVoices.push({ osc, gain, endTime: this.ctx.currentTime + duration });
      }

      getThemeNote(theme) {
        if (!theme.intervals || theme.intervals.length === 0) return null;
        
        const interval = theme.intervals[this.themeIndex % theme.intervals.length];
        const rhythm = theme.rhythm[this.themeIndex % theme.rhythm.length];
        
        this.themeIndex++;
        
        return {
          note: interval,
          duration: rhythm
        };
      }

      noteToFreq(interval, octave = 4) {
        const baseFreq = 293.66; // D4
        const semitones = interval + this.transposition + (octave - 4) * 12;
        return baseFreq * Math.pow(2, semitones / 12);
      }

      formatTime(seconds) {
        const mins = Math.floor(seconds / 60);
        const secs = Math.floor(seconds % 60);
        return `${mins}:${secs.toString().padStart(2, '0')}`;
      }

      fadeOut() {
        this.masterGain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 10);
        setTimeout(() => {
          this.active = false;
          this.ctx.close();
        }, 10000);
      }

      updateUI() {
        this.elements.stageName.textContent = this.currentAct ? this.currentAct.name : 'PRELUDE';
        this.elements.bpmDisplay.textContent = Math.round(this.bpm);
        this.elements.keyDisplay.textContent = `${this.key} ${this.mode.toUpperCase()}`;
        
        const tensionPercent = this.tension * 100;
        this.elements.tensionBar.style.width = tensionPercent + '%';
        
        const dynamicsPercent = this.dynamics * 100;
        this.elements.dynamicsBar.style.width = dynamicsPercent + '%';
        
        this.elements.voiceCount.textContent = this.activeVoices.length;
        
        // Update spectrum
        if (this.analyser && this.dataArray) {
          this.analyser.getByteFrequencyData(this.dataArray);
          this.spectrumBars.forEach((bar, i) => {
            const height = (this.dataArray[i] / 255) * 80 * this.dynamics;
            bar.style.height = height + 'px';
          });
        }
      }

      animate() {
        const loop = () => {
          if (!this.active) return;
          
          // Update orb position
          this.elements.orb.style.left = this.pos.x + '%';
          this.elements.orb.style.top = this.pos.y + '%';
          
          // Pulse on beat
          if (this.step % 16 === 0) {
            this.elements.orb.classList.add('pulse');
            setTimeout(() => this.elements.orb.classList.remove('pulse'), 150);
          }
          
          // Update UI
          if (this.step % 4 === 0) {
            this.updateUI();
          }
          
          // Background based on act and intensity
          const actColors = {
            'PRELUDE': ['#000', '#0a0a0a'],
            'ACT I': ['#0a0a0a', '#1a1a1a'],
            'ACT II': ['#1a1a1a', '#2a1a1a'],
            'ACT III': ['#2a1a1a', '#3a2a1a'],
            'CODA': ['#1a1a1a', '#000']
          };
          
          const colors = actColors[this.currentAct?.name] || ['#000', '#0a0a0a'];
          const gradient = `radial-gradient(circle at ${this.pos.x}% ${this.pos.y}%, 
            ${colors[0]} ${10 * this.intensity}%, 
            ${colors[1]} ${50 + 30 * this.dynamics}%)`;
          
          document.body.style.background = gradient;
          
          // Cinematic overlay based on tension
          this.elements.cinematicOverlay.classList.toggle('active', this.tension > 0.5);
          
          requestAnimationFrame(loop);
        };
        requestAnimationFrame(loop);
      }
    }

    new CinematicOrchestra();
  </script>
</body>
</html>
